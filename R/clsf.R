## Using probabilities of marker expression, assign scores for each class
##   in one or more dichotomies of interest via Naive Bayes
##
## by Artem Sokolov

#' Identifies a marker with the highest probability of expression
#' @param P Posterior probabilities, as generated by GMMreshape()
#' @param cid Column containing cell IDs
#' @param vm (optional) vector of markers to limit the argmax to
#' @param pthr probability threshold above which a cell is considered to express the marker
#' @return The original dataframe P augmented with the dominant marker column
#' @importFrom magrittr %>%
#' @export
findDominant <- function( P, cid, vm, pthr = 0.65 )
{
    P1 <- P %>% dplyr::mutate( tmpID = 1:(dplyr::n()) )
    if( missing(vm) )
        vm <- dplyr::select(P, -{{cid}}) %>% colnames

    vm <- c(vm, "None")
    
    P1 %>%
        dplyr::mutate( None = pthr ) %>%
        dplyr::select( tmpID, all_of(vm) ) %>%
        tidyr::gather( Dominant, Value, vm ) %>%
        dplyr::group_by( tmpID ) %>% dplyr::slice(which.max(Value)) %>%
        dplyr::ungroup() %>% dplyr::arrange( tmpID ) %>%
        dplyr::inner_join( P1, by="tmpID" ) %>%
        dplyr::select( -tmpID, -Value ) %>%
        dplyr::select( {{cid}}, Dominant, everything() )
}

#' Calls cell states according to a marker -> cell state mapping
#' @param P Posterior probabilities, as generated by GMMreshape()
#' @param cid Column containing cell IDs
#' @param mct A data frame with columns Marker and State, defining the mapping between the two
#' @return The original dataframe P augmented with a State column
#' @importFrom magrittr %>%
#' @export
callStates <- function( P, cid, mct )
{
    stopifnot( all(c("Marker", "State") %in% colnames(mct)) )
    
    ## Convert cell id string to symbol
    sid <- rlang::sym(cid)
    
    ## Compute log(P) of all relevant markers
    logP <- P %>% dplyr::select( dplyr::all_of(mct$Marker) ) %>%
        dplyr::mutate( dplyr::across(dplyr::everything(), log) )

    ## For a given state, compute the geometric mean of its marker probabilities
    ## Make the final call based on the largest value
    mct %>% dplyr::group_by( State ) %>%
        dplyr::summarize( dplyr::across(Marker, list), .groups="drop" ) %>%
        dplyr::mutate( Post = purrr::map(Marker, ~rowMeans(logP[,.x])) ) %>%
        dplyr::select( -Marker ) %>% tibble::deframe() %>%
        dplyr::bind_cols( select(P, tmpID = !!sid), . ) %>%
        tidyr::pivot_longer( -tmpID, names_to="State" ) %>%
        dplyr::group_by( tmpID ) %>%
        dplyr::slice(which.max(value)) %>%
        dplyr::ungroup() %>%
        dplyr::select( !!sid := tmpID, State ) %>%
        dplyr::inner_join( P, by=str_c(sid) )
}
